<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Temple Run (JS)</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial}
  #gameWrap{display:flex;flex-direction:column;align-items:center;gap:6px;padding:10px}
  canvas{background:linear-gradient(#4d2,#2a2);border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.4)}
  #hud{display:flex;align-items:center;gap:12px;color:#fff;font-weight:600}
  .btn {background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.15);
        color:#fff;padding:6px 10px;border-radius:8px;cursor:pointer}
  #controlsMobile{display:none;gap:8px;margin-top:8px}
  #controlsMobile button{padding:12px 16px;font-weight:700;border-radius:10px}
  @media (max-width:600px){
    canvas{width:360px;height:640px}
    #controlsMobile{display:flex}
  }
  .small{font-size:0.9rem;opacity:0.9}
  #overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;
    align-items:center;justify-content:center;pointer-events:none}
  #msg{background:rgba(0,0,0,.7);color:#fff;padding:18px;border-radius:12px;pointer-events:auto}
</style>
</head>
<body>
<div id="gameWrap">
  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div class="small">Speed: <span id="speedDisp">1.0</span>x</div>
    <button id="pauseBtn" class="btn">Pause</button>
    <button id="restartBtn" class="btn">Restart</button>
  </div>

  <canvas id="game" width="400" height="700"></canvas>

  <div id="controlsMobile">
    <button id="leftTouch" class="btn">◀️</button>
    <button id="jumpTouch" class="btn">▲</button>
    <button id="rightTouch" class="btn">▶️</button>
  </div>
</div>

<div id="overlay"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Game constants
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  const LANE_COUNT = 3;
  const LANE_WIDTH = WIDTH / LANE_COUNT;
  const GROUND_Y = HEIGHT - 100;
  const GRAVITY = 0.98;
  const JUMP_VEL = -16;
  const START_SPEED = 4;
  const MAX_OBSTACLES = 6;

  // State
  let score = 0;
  let speed = START_SPEED;
  let running = true;
  let paused = false;
  let frame = 0;

  // UI refs
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speedDisp');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const overlay = document.getElementById('overlay');

  // Player
  const player = {
    lane: 1, // 0-left,1-center,2-right
    x: laneToX(1),
    y: GROUND_Y - 48,
    width: 36,
    height: 48,
    vy: 0,
    jumping: false,
    color: '#FFD27F'
  };

  // Entities
  let obstacles = [];
  let coins = [];

  function laneToX(lane) {
    // center horizontally in lane
    return lane * LANE_WIDTH + (LANE_WIDTH - player.width) / 2;
  }

  function reset() {
    score = 0;
    speed = START_SPEED;
    running = true;
    paused = false;
    frame = 0;
    obstacles = [];
    coins = [];
    player.lane = 1;
    player.x = laneToX(1);
    player.y = GROUND_Y - player.height;
    player.vy = 0;
    player.jumping = false;
    overlay.innerHTML = '';
    updateUI();
  }

  function spawnObstacle() {
    const lane = Math.floor(Math.random() * LANE_COUNT);
    const w = 36 + Math.random() * 30;
    const h = 36 + Math.random() * 36;
    obstacles.push({
      lane,
      x: lane * LANE_WIDTH + (LANE_WIDTH - w) / 2,
      y: -h - Math.random() * 60,
      width: w,
      height: h,
      color: '#6b3b16'
    });
  }

  function spawnCoin() {
    const lane = Math.floor(Math.random() * LANE_COUNT);
    coins.push({
      lane,
      x: lane * LANE_WIDTH + (LANE_WIDTH - 20) / 2,
      y: -20 - Math.random() * 80,
      radius: 10,
      collected: false
    });
  }

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    if (['ArrowLeft','ArrowRight','ArrowUp',' ','Spacebar'].includes(e.key)) e.preventDefault();
    keys[e.key] = true;
    handleInput();
  });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  // Mobile controls
  document.getElementById('leftTouch').addEventListener('touchstart', e => { e.preventDefault(); moveLeft(); });
  document.getElementById('rightTouch').addEventListener('touchstart', e => { e.preventDefault(); moveRight(); });
  document.getElementById('jumpTouch').addEventListener('touchstart', e => { e.preventDefault(); jump(); });

  pauseBtn.onclick = () => {
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if (!paused) requestAnimationFrame(loop);
  };
  restartBtn.onclick = () => reset();

  function handleInput() {
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveLeft();
    if (keys['ArrowRight'] || keys['d'] || keys['D']) moveRight();
    if (keys['ArrowUp'] || keys[' ']) jump();
  }

  function moveLeft() {
    if (player.lane > 0 && !player.moving) {
      player.lane -= 1;
      player.x = laneToX(player.lane);
      // small slide effect could be added
    }
  }
  function moveRight() {
    if (player.lane < LANE_COUNT - 1 && !player.moving) {
      player.lane += 1;
      player.x = laneToX(player.lane);
    }
  }
  function jump() {
    if (!player.jumping) {
      player.vy = JUMP_VEL;
      player.jumping = true;
    }
  }

  function update(dt) {
    frame++;
    // Gradually increase speed -> harder over time
    if (frame % 120 === 0) speed += 0.08;

    // spawn entities occasionally
    if (Math.random() < 0.02 + speed * 0.002 && obstacles.length < MAX_OBSTACLES) spawnObstacle();
    if (Math.random() < 0.015) spawnCoin();

    // Update obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const ob = obstacles[i];
      ob.y += speed * 2 + dt * 0.05 * speed;
      // past screen?
      if (ob.y > HEIGHT + 200) obstacles.splice(i, 1);
    }
    // Update coins
    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      c.y += speed * 2;
      if (c.y > HEIGHT + 50) coins.splice(i, 1);
    }

    // Player physics
    if (player.jumping) {
      player.vy += GRAVITY * 0.6;
      player.y += player.vy;
      if (player.y >= GROUND_Y - player.height) {
        player.y = GROUND_Y - player.height;
        player.vy = 0;
        player.jumping = false;
      }
    }

    // Collision detection
    // Player bounding box
    const pbox = {x: player.x, y: player.y, w: player.width, h: player.height};

    // Obstacles collision
    for (let ob of obstacles) {
      const obBox = {x: ob.x, y: ob.y, w: ob.width, h: ob.height};
      if (rectIntersect(pbox, obBox)) {
        gameOver();
        return;
      }
    }

    // Coins collision
    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      const cx = c.x + c.radius;
      const cy = c.y + c.radius;
      if (cx > pbox.x && cx < pbox.x + pbox.w &&
          cy > pbox.y && cy < pbox.y + pbox.h) {
        // collect
        score += 10;
        coins.splice(i, 1);
      }
    }

    // Score increases with survival
    score += Math.floor(dt * 0.02 * speed);
    updateUI();
  }

  function rectIntersect(a,b){
    return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
  }

  let lastTime = performance.now();
  function loop(now) {
    if (!running) return;
    if (paused) {
      lastTime = now;
      return;
    }
    const dt = now - lastTime;
    lastTime = now;

    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  function render() {
    // Clear
    ctx.clearRect(0,0,WIDTH,HEIGHT);

    // Draw ground
    ctx.fillStyle = '#2d5a2d';
    ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);

    // Road lanes visual
    for (let i=0;i<LANE_COUNT;i++){
      const x = i * LANE_WIDTH;
      ctx.fillStyle = (i%2===0)?'rgba(0,0,0,0.08)':'rgba(255,255,255,0.02)';
      ctx.fillRect(x+6, 0, LANE_WIDTH-12, HEIGHT);
      // lane guide
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.beginPath();
      ctx.moveTo(x+LANE_WIDTH/2, 0);
      ctx.lineTo(x+LANE_WIDTH/2, HEIGHT);
      ctx.stroke();
    }

    // Draw obstacles (closer objects larger)
    for (let ob of obstacles){
      // simple perspective scale based on y (further up -> smaller)
      const depth = 1 + (ob.y / (HEIGHT));
      ctx.fillStyle = ob.color;
      ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
      ctx.strokeStyle = '#3f2a10';
      ctx.strokeRect(ob.x, ob.y, ob.width, ob.height);
    }

    // Draw coins
    for (let c of coins){
      ctx.beginPath();
      ctx.fillStyle = '#ffd700';
      ctx.arc(c.x + c.radius, c.y + c.radius, c.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#b8860b';
      ctx.stroke();
    }

    // Draw player (simple rectangular runner with a "head")
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(player.x + 6, player.y + 6, player.width - 12, 12); // visor

    // HUD guide (lane markers)
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    for (let i = 0; i < LANE_COUNT; i++){
      ctx.fillRect(i*LANE_WIDTH + LANE_WIDTH/2 - 2, GROUND_Y + 6, 4, 28);
    }
  }

  function updateUI(){
    scoreEl.textContent = score;
    speedEl.textContent = speed.toFixed(2);
  }

  function gameOver(){
    running = false;
    showOverlay(`Game Over<br>Score: ${score}<br><button id="retry" class="btn">Play Again</button>`);
    document.getElementById('retry').onclick = () => {
      reset();
      requestAnimationFrame(loop);
    };
  }

  function showOverlay(html){
    overlay.innerHTML = '';
    const box = document.createElement('div');
    box.id = 'msg';
    box.innerHTML = html;
    overlay.appendChild(box);
    overlay.style.pointerEvents = 'auto';
  }

  // Start the game loop
  reset();
  requestAnimationFrame(loop);

  // simple auto-pause when window loses focus
  window.addEventListener('blur', () => { paused = true; pauseBtn.textContent = 'Resume'; });
  window.addEventListener('focus', () => { /* keep paused state as-is */ });

  // Adapt to pointer / swipe for mobile lanes
  let touchStartX = null;
  canvas.addEventListener('touchstart', e => {
    const t = e.touches[0];
    touchStartX = t.clientX;
  }, {passive:true});
  canvas.addEventListener('touchend', e => {
    if (touchStartX == null) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    if (dx < -30) moveLeft();
    else if (dx > 30) moveRight();
    else jump();
    touchStartX = null;
  });

})();
</script>
</body>
</html>
